#!/usr/bin/env python3

import glob
import json
import os
from datetime import datetime
from collections import defaultdict
import argparse
import re
from pathlib import Path
import xml.etree.ElementTree as et
from .utils import exit_program_early, debug_logging, log_linebreak
import logging

logger = logging.getLogger(__name__)

@debug_logging
def get_locals_from_xml(xml_path: Path) -> set:
    """
    Read in the xml file to find the localizers.

    :param xml_path: Path to XML generated by XNAT
    :type xml_path: pathlib.Path
    :return: Set containing all localizer IDs
    :rtype: set
    """
    tree = et.parse(xml_path)
    prefix = "{" + str(tree.getroot()).split("{")[-1].split("}")[0] + "}"
    scan_element_list = list(tree.iter(f"{prefix}scans"))
    
    if len(scan_element_list) != 1:
        exit_program_early(f"Error parsing the xml file provided. Found none or more than one scan groups")
    
    scans = scan_element_list[0]
    
    localizers = set()
    for s in scans:
        if re.match(r"Localizer.*", s.get("type")) and s.find(f'{prefix}quality').text == "usable":
            localizers.add(int(s.get("ID")))
    return sorted(localizers)


@debug_logging
def get_func_from_bids(bids_path: Path,
                       localizers: set[int],
                       json_dict: defaultdict[list],
                       groupings: list[dict[str:set]]):
    """
    Read in the JSON associated with task-based runs from the bids dir, and pair with a localizer run.

    :param bids_path: path to BIDS-compliant .nii/.json files
    :type bids_path: pathlib.Path
    :param localizers: set of localizer IDs
    :type localizers: set[int]
    :param json_dict: dict with each key being a series number, each value being an object representation of it's JSON file with added 'bidsname' and 'filename' attributes
    :type json_dict: defaultdict[list]
    :param groupings: list of dictionaries containing mappings of localizers to series number
    :type groupings: list[dict[str:set]]
    """
    bids_func_json = sorted(list(bids_path.glob("func/*bold.json")))
    # assert len(bids_func_json) > 0, "---[ERROR]: Could not find any JSON files for bold runs in the functional directory of the bids data"
    if len(bids_func_json) == 0:
        exit_program_early("Could not find any JSON files for bold runs in the functional directory of the bids data.")
    for jf in bids_func_json:
        jd = None
        with open(jf, "r") as j:
            jd = json.load(j)
        series_num = int(jd["SeriesNumber"])
        jd["bidsname"] = f"{bids_path.name}/func/{jf.name.split('/')[-1][:-4]}nii.gz"
        jd["filename"] = str(jf)
        json_dict[series_num].append(jd)
        for i, l in enumerate(localizers):
            if i < len(localizers)-1:
                if series_num > l and series_num < localizers[i+1]:
                    groupings[i]["task"].add(series_num)
                    break
            else:
                groupings[i]["task"].add(series_num)


# Read in the json for the field maps from the bids dir
@debug_logging
def get_fmap_from_bids(bids_path: Path,
                       localizers: set[int],
                       json_dict: defaultdict[list],
                       groupings: list[dict[str:set]]):
    """
    Read in all fmap JSON from the bids dir, and pair to a localizer.

    :param bids_path: path to BIDS-compliant .nii/.json files
    :type bids_path: pathlib.Path
    :param localizers: set of localizer IDs
    :type localizers: set[int]
    :param json_dict: dict with each key being a series number, each value being an object representation of it's JSON file with added 'bidsname' and 'filename' attributes
    :type json_dict: defaultdict[list]
    :param groupings: list of dictionaries containing mappings of localizers to series number
    :type groupings: list[dict[str:set]]
    """
    bids_fmap_json = sorted(list(bids_path.glob("fmap/*.json")))
    # assert len(bids_fmap_json) > 0, "---[ERROR]: Could not find any JSON files from the fieldmap directory of the bids data"
    if len(bids_fmap_json) == 0:
        exit_program_early("Could not find any JSON files from the fieldmap directory of the bids data.")
    for jf in bids_fmap_json:
        jd = None
        with open(jf, "r") as j:
            jd = json.load(j)
        series_num = int(jd["SeriesNumber"])
        jd["filename"] = jf.name.split("/")[-1]
        json_dict[series_num].append(jd)
        direction = "fmapAP" if jd["PhaseEncodingDirection"] == "j-" else "fmapPA"
        for i, l in enumerate(localizers):
            if i < len(localizers)-1:
                if series_num > l and series_num < localizers[i+1]:
                    groupings[i][direction].add(series_num)
                    break
            else:
                groupings[i][direction].add(series_num)


@debug_logging
def map_fmap_to_func(xml_path: Path,
                     bids_dir_path: Path):
    """
    Group field maps to BOLD task runs.

    :param xml_path: path to XML generated by XNAT
    :type xml_path: pathlib.Path
    :param bids_dir_path: path to BIDS-compliant session directory
    :type bids_dir_path: pathlib.Path
    """
    log_linebreak()
    logger.info("####### Pairing field maps to functional runs #######\n")

    if not xml_path.is_file():
        exit_program_early(f"Session xml file {xml_path} does not exist.")
    if not bids_dir_path.is_dir():
        exit_program_early(f"Session bids dicrectory {bids_dir_path} does not exist.")
    series_json = defaultdict(list)

    locals_series = get_locals_from_xml(xml_path=xml_path)
    logger.info(f"Localizers: {locals_series}")

    groups = [{"task":set(), "fmapAP": set(), "fmapPA": set()} for _ in locals_series]
    get_func_from_bids(bids_path=bids_dir_path, 
                       localizers=locals_series, 
                       json_dict=series_json, 
                       groupings=groups)
    get_fmap_from_bids(bids_path=bids_dir_path, 
                       localizers=locals_series, 
                       json_dict=series_json, 
                       groupings=groups)
    logger.info(f"Localizer groups: {groups}") 

    for group in groups:
        # assert len(group["fmapAP"]) == len(group["fmapPA"]), "Unequal number of AP and PA field maps!"
        if len(group["fmapAP"]) != len(group["fmapPA"]):
            exit_program_early("Unequal number of AP and PA field maps.")
        fmap_pairs = tuple(zip(sorted(group["fmapAP"]), sorted(group["fmapPA"])))
        fmap_times = []

        # get times for field maps
        for i,p in enumerate(fmap_pairs):
            times = sorted((datetime.strptime(series_json[p[0]][0]["AcquisitionTime"], "%H:%M:%S.%f"),
                            datetime.strptime(series_json[p[1]][0]["AcquisitionTime"], "%H:%M:%S.%f")))
            fmap_times.append(times[0] + (abs(times[1] - times[0])/2))
        
        # pair task runs with field maps based on closest Acquisition Time
        map_pairings = {s:[] for s in fmap_pairs}
        for t in group["task"]:
            aqt = datetime.strptime(series_json[t][0]["AcquisitionTime"], "%H:%M:%S.%f")
            diff = list(map(lambda x: abs(x-aqt), fmap_times))
            pairing = fmap_pairs[diff.index(min(diff))]
            map_pairings[pairing].append(t)
        logger.info(f"Field map pairings: {map_pairings}")

        # add the list of task run files that are paired with each field map in their json files
        for k,v in map_pairings.items():
            for s in k:
                jd = series_json[s][0]
                file = jd.pop("filename")
                jd["IntendedFor"] = []
                for t in v:
                    for echo in series_json[t]:
                        jd["IntendedFor"].append(echo["bidsname"])
                fmap_file = bids_dir_path/f"fmap/{file}"
                with open(fmap_file, "w") as out_file:
                    logger.debug(f"writing field map pairing information to file: {fmap_file}")
                    out_file.write(json.dumps(jd, indent=4))

def map_fmap_to_func_with_pairing_file(bids_dir_path: Path,
                                       pairing_json: Path):
    log_linebreak()
    for json_path in bids_dir_path.glob("fmap/*json"): # reset IntendedFor field in all fmap json
        with open(json_path) as f:
            json_obj = json.load(f)
        json_obj["IntendedFor"] = []
        with open(json_path, "w") as f:
            json.dump(json_obj, f, indent=4)
    logger.info("####### Pairing field maps to functional runs using pairing file #######\n")
    with pairing_json.open() as f:
        pairing_dict = json.load(f)
    pairings_list = pairing_dict["pairings"]
    for pairing in pairings_list:
        fmap_jsons = bids_dir_path.glob(f"fmap/*{pairing['fmap']}*json")
        func_paths = []
        for func in pairing["func"]:
            func_paths.extend(
                [str(p) for p in bids_dir_path.parent.glob(f"*/func/*{func}*nii.gz")]
            )
        for fmap_json in fmap_jsons:
            with fmap_json.open() as f:
                fmap_dict = json.load(f)
            fmap_dict["IntendedFor"] = func_paths
            with fmap_json.open('w') as f:
                json.dump(fmap_dict, f, indent=4)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="group_series.py", 
        description="Grouping field maps to BOLD task runs"
    )
    parser.add_argument("xml_ses_file", type=Path, help="The path to the xml file for this session")
    parser.add_argument("bids_ses_dir", type=Path, help="The path to the bids directory for this session")
    args = parser.parse_args()

    map_fmap_to_func(xml_path=args.xml_ses_file, 
                     bids_dir_path=args.bids_ses_dir)
